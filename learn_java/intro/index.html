<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Introduction to Test-First Training</title>
  </head>

  <body>
    <h1>Introduction to Test-First Training</h1>


    <h2>Some Definitions</h2>

    <p>
      <b>Unit Testing</b> refers to writing a set of functions that
      sit next to a given module of program code.  These functions run
      a series of tests that assure, more-or-less thoroughly, that the
      program code performs as it is supposed to.
    </p>
    
    <p>
      For example, assume there is a function called <tt>add</tt> that
      takes two integers as parameters, adds them together, and
      returns their sum.  There might be one unit test that calls
      <tt>add</tt> with 2 and 3, and makes sure the result is 5.
      There might be additional unit tests that "push the envelope" in
      various other ways, testing its behavior with large numbers,
      negative numbers, illegal parameters (e.g. strings), and so
      forth.
    </p>

    <p>
      Once a full suite of unit tests is developed, it is good
      practice to run these tests as often as possible.
    </p>

    <p>
      <b>Test-First Development</b> (sometimes called <b>Test-Driven
      Development</b> or <b>Test-Driven Design</b>) is the practice of
      writing the unit tests <i>first</i>, before you write a single
      line of implementation code.  While this may seem like putting
      the cart before the horse, there are several good reasons why
      you might want to do this:
    </p>
    <ol>
      <li>
	It forces you to think first about the design of the
	<i>interface</i> to the code, instead of jumping straight to the
	<i>implementation</i>.  Having a well-designed interface is
	often more important than having an efficient implementation.
      </li>
      <li>
	Writing tests is often seen as a chore; writing the tests
	first guarantees that at the end of the day you will have
	written a suite of unit tests (rather than leaving them until
	the end and possibly never getting around to it).
      </li>
      <li>
	If you apply a tight cycle of write one test, then write the
	code to implement that test, then write the next test, your
	code ends up growing organically.  This often (though not
	always) leads to less wasted effort; you end up writing all
	the code you need, and none of the code you don't need.
      </li>
    </ol>

    <p>
      A <b>Unit Testing Framework</b> is a tool or library that
      provides a backdrop for writing unit tests. For example, to
      implement a unit test in the popular 

      <A href="http://junit.org">
	JUnit framework,</a> 

      you write a class that extends the common TestCase superclass.
      Each method in your subclass that begins with the word "test" is
      a separate unit test.  You then run the JUnit tool (both
      graphical and text versions are provided) and it loads your
      class and executes each test method in turn, monitoring the
      results and providing feedback.
    </p>

    <p>
      <b>Test-First Training</b> follows the example of Test-First
      Development, but with an educational twist.  In Test-First
      Training, the student begins with a single unit test (written by
      the teacher).  In order to implement the test, the student has
      to create source code <i>from scratch</i>.  The student then
      tries to compile and run the test; if the test cannot compile,
      or if the test runs and fails, then the student must go and fix
      his error.  He then moves on to the next test in the lesson.
    </p>

    <h2>Why Test-First Training?</h2>

    <p>
      In traditional programming exercises, you are either given a
      fairly large task and asked to implement the whole thing, or you
      are provided with "skeleton code" -- source code that has been
      eviscerated to remove key sections, which you are asked to fill
      in.
    </p>

    <p>
      "Large task" exercises are often challenging to students because
      of their sheer size.  Many lines of code need to be written
      before the student receives any positive reinforcement that they
      are on the right track.  This can be frustrating to a beginning
      student, and boring to an advanced one. 
    </p>

    <p>
      "Skeleton code" exercises are also frustrating.  The task of the
      student should be to figure out how to write code that will
      accomplish the given task.  With skeleton code, they are first
      presented with the task of figuring out what the original author
      was trying to do; of reading through his code (often littered
      with idiosyncratic idioms and obscure comments); and then of
      trying to implement just one part of the algorithm he chose,
      without necessarily understanding the larger picture.  If the
      fill-in-the-blank code section is too complicated, he may never
      complete the assignment; if it's too simple, he may proceed
      without having learned a thing.
    </p>

    <p>
      Finally, in both types of traditional exercises, the student
      doesn't really know when he's finished!  Sometimes, he will
      succeed in the task, but neglect to print his results, and will
      keep at it, believing he's still missing something; other times,
      he will write code that seems to work but is crucially flawed in
      some way or another. This is one of the most powerful features
      of test-first development -- you code until the test passes, and
      then you stop coding.  The test provides a map to the student,
      informing him of where to begin, and where to end.
    </p>
    
    <p>
      Test-first training is appropriate for both local and remote
      use.  If a student is in a classroom, he may rely on his
      classmates or teachers for guidance; but if he is alone, the
      tests provide some measure of feedback and guidance (although
      unit tests can never actually debug his code).
    </p>

    <p>
      Perhaps the most important aspect of test-first training is that
      it teaches the whole process, from opening a new file in a text
      editor to compiling and running.  At the end of the day, the
      students can say, "At least I know how to write a program."
      Many exercises, especially skeletons but also those based on
      tools and toy problems, end up skipping the fundamentals that
      are vital not just for coding on a day-to-day basis, but also
      for cementing the higher-level concepts into habits and skills.
      (For a Java example, if a student is always provided with a
      skeleton <tt>main()</tt> method, he may end up never memorizing
      the cryptic but essential incantation, "<tt>public static void
      main(String[] args)</tt>").
    </p>

    <h2>How To Use These Exercises</h2>

    <p>
      The exercises are divided into modules.  Each module contains
      several tests.  For each test, you are to write all the code to
      make it run.  Let's walk through this process for a sample
      module.  (Here we assume that you've already installed the Java
      Development Kit, sometimes called JDK or J2SDK, and configured
      it for your system.)
    </p>
    <ol>
      <li>
	Open a command prompt.
	<br /><br />
      </li>
      <li>
	Change directories to the "intro" module. 
	<pre>cd intro</pre>
	<br /><br />
      </li>
      <li>
	Look at the two test files in the directory.
	<pre>(IntroTest0.java and IntroTest1.java)</pre>
	<br /><br />
      </li>
      <li>
	Try to compile the first test using javac, the Java Compiler.
	<pre>javac IntroTest0.java</pre>
	<br /><br />
      </li>
      <li>
	This should fail!  You will get an error message that looks
	something like this:
	<pre>
$ javac IntroTest0.java
IntroTest0.java:5: cannot resolve symbol
symbol  : class Intro  
location: class IntroTest0
        Intro x = new Intro();
        ^
IntroTest0.java:5: cannot resolve symbol
symbol  : class Intro  
location: class IntroTest0
        Intro x = new Intro();
                      ^
	</pre> 

	This is the Java compiler telling you that you need an object
	(class) named Intro. 
	<br /><br />
      </li>
      <li>
	Create a class named Intro.  Using your favorite text editor,
	make a file called "Intro.java" (capitalization <b>is very
	important</b> in Java, so make sure the "I" is capitalized),
	in the <tt>intro</tt> directory, and put the following text
	into it:
	<pre>
public class Intro
{
}
	</pre>
	
	This is the way you create a "stub class", or an object that
	doesn't do anything yet.
	<br /><br />
      </li>
      <li>
	Try to compile IntroTest0.java again.
	<pre>javac IntroTest0.java</pre>
	<br /><br />
      </li>
      <li>
	It should fail again!  This time, the message will be
	something like:
	<pre>
IntroTest0.java:6: cannot resolve symbol
symbol  : method getHello  ()
location: class Intro
        assertEquals("Hello", x.getHello());
                               ^
1 error
	</pre> 

	This is typical for test-first development.  You may have to
	mess with your implementation code several times before the
	test will compile.  (This is partly because Java is a
	<b>strongly typed</b> language, and refuses to cooperate until
	it has a lot of information about the other classes in your
	world.) 
	
	<br /><br />
      </li>
      <li>
	Make Intro.java look like this:
	<pre>
public class Intro
{
    public String getHello()
    {
        return "Goodbye";
    }
}
	</pre>
	<br /><br />
      </li>
      <li>
	Compile the test one more time.
	<pre>javac IntroTest0.java</pre>
	<br /><br />
      </li>
      <li>
	Now run the test, using the <tt>java</tt> executable.
	<pre>java IntroTest0</pre>
	<br /><br />
      </li>
      <li>
	This should also fail!  (Are you getting used to failure yet?)
	This is meant to simulate you not getting the answer right the
	first time.  You should see a message like:
	<pre>
Running IntroTest0
testHello...FAILURE
Test$AssertionFailed: Expected &lt;Hello&gt; but got &lt;Goodbye&gt;
	at Test.fail(Test.java:17)
	at Test.assertEquals(Test.java:24)
	at IntroTest0.testHello(IntroTest0.java:6)
	at java.lang.reflect.Method.invoke(Native Method)
	at Test.runTests(Test.java:136)
	at Test.runTests(Test.java:90)
	at Test.main(Test.java:70)

OK: 0 FAILED: 1
	</pre>
	This is the Test program telling you that it tried to run the
	test case called "testHello" but it failed.  The test case was
	expecting to get back the string "Hello" but instead, it got
	the string "Goodbye".  To be helpful, it lists the exact
	source file and line number where the assertion was made.
	Look down the list of "at" lines until you see the one caused
	by your specific test case.
	<pre>at IntroTest0.testHello(IntroTest0.java:6)</pre>
	Open up this file (IntroTest0.java) and look at line 6.
	<pre>assertEquals("Hello", x.getHello());</pre>
	This gives you a big hint that the problem is somewhere inside
	the method called <tt>getHello()</tt>.
	<br /><br />
      </li>
      <li>
	Go back to Intro.java and fix it.
	<pre>
public class Intro
{
    public String getHello()
    {
        return "Hello";
    }
}
	</pre>
	<br /><br />
      </li>
      <li>
	Recompile and rerun the test. (Always be sure to recompile!)
	<pre>
javac IntroTest0.java
java IntroTest0
	</pre>
	<br /><br />
      </li>
      <li>
	Now, for extra credit, compile and run
	<tt>IntroTest1.java</tt>, and try to make it pass.
	<br /><br />
      </li>
    </ol>
    
    <p>
      Still with me?  Good!  You are now ready to begin.  For each
      module, try to make each test pass, in numerical order.  Each
      module has an index.html page that gives you background on the
      programming tasks, and hints on how to complete individual
      tests.
    </p>
    
    <hr> 

    All contents Copyright (C) 2002-2003 by Alex Chaffee and Purple
    Technology.  All rights reserved.  Please do not distribute
    without permission.  For more information, contact
    alex@purpletech.com.

    <hr>
    <address><a href="mailto:alex@stinky.com">Alex Chaffee</a></address>
<!-- Created: Mon Jul 15 15:21:23 PDT 2002 -->
<!-- hhmts start -->
Last modified: Thu Aug  1 00:30:00 PDT 2002
<!-- hhmts end -->
  </body>
</html>
